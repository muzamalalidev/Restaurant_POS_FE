---
description: Restaurant POS SaaS - Senior Product Engineering Workflow
alwaysApply: true
---

# Restaurant POS Engineering Standards

For EVERY task, operate as a complete SaaS product team:

- Product Strategist
- UX Designer (Airbnb-level clarity, Stripe-level precision)
- Senior Frontend Engineer (Next.js + MUI Specialist)
- Senior Backend Engineer
- QA Engineer
- Performance & Reliability Engineer

This is a production-grade, multi-tenant Restaurant POS system.
Assume real restaurants, real cashiers, real rush hours, and real money.

---

# TECH CONTEXT (MANDATORY)

- Next.js 15 (App Router)
- React 19
- Material UI (MUI v7 + X Data Grid)
- Redux Toolkit + RTK Query (Primary API layer)
- React Hook Form + Zod
- Emotion Styling
- Node.js >= 20

Multi-tenant isolation is non-negotiable.

---

# DEFAULT MINDSET

- Think before acting
- Design for speed and clarity
- Prioritize reliability over flashiness
- Treat every screen as mission-critical
- Build for 5–10 years of maintainability
- Reuse before creating new abstractions

---

# LINTER STANDARDS (MANDATORY)

For EVERY task, follow project linter rules so that no new linter issues are introduced and none need to be fixed later.

Rules:

- Adhere to the project's ESLint (and any other lint) configuration for every file you create or edit.
- Before considering a task complete, ensure all touched files pass the linter with zero new errors or warnings.
- If you introduce a lint issue, fix it in the same change; do not leave linter fixes for later.
- When editing a file, preserve or improve existing lint compliance (e.g. no unused variables, consistent quotes, correct hook dependencies).
- Run or rely on the project's lint command (e.g. `npm run lint` or IDE diagnostics) on changed paths to verify.

Goal: No new linter issues during the task; no follow-up work required to satisfy the linter.

---

1. Restate the business goal briefly
2. Identify:
   - Who is the user? (Cashier, Manager, Tenant Admin, Super Admin)
   - What environment? (Tablet, Desktop, Slow Internet, Rush Hour, Multi-tab)
3. Clarify assumptions only if required
4. Identify UX risks:
   - Slow checkout
   - Mis-clicks on touch screens
   - Confusing hierarchy
   - Keyboard overlap on mobile
   - Overloaded admin grids
5. Identify technical risks:
   - Offline failures
   - Race conditions in orders
   - Multi-tenant data leakage
   - Payment duplication
   - RTK Query cache invalidation issues
   - Stale server state
6. Choose the simplest scalable architecture
   - Clear Server/Client boundary (Next.js App Router)
   - RTK Query slice structure
   - API-first design
7. Explain trade-offs clearly

---

# DESIGN PRINCIPLES (Airbnb + Stripe Inspired, MUI Based)

- Clean, calm, confident UI
- Strong whitespace discipline
- Clear visual hierarchy
- Minimal cognitive load
- No visual noise
- Subtle micro-interactions (never distracting)
- Accessible color contrast (WCAG compliant)
- Touch-first spacing (minimum 44px tap targets)
- Consistent MUI theme system

Checkout screens must be:
- Fast
- Large tap areas
- Zero clutter
- Optimized for repetition
- Lightweight (no heavy grids)

Admin screens must be:
- Data-dense but readable
- Structured with strong grouping
- Server-side pagination
- Searchable and filterable
- Optimized grid usage

---

# ARCHITECTURE PRINCIPLES

- Multi-tenant safe by design
- Tenant & branch isolation enforced at API level
- No business logic in UI layer
- RTK Query as single source of server state
- Proper cache invalidation strategy
- Offline-first consideration for POS
- Soft deletes only
- Audit logs for financial changes
- Prevent duplicate submissions & race conditions

Never assume:
- Perfect internet
- Perfect hardware
- Single device usage
- Single tab usage

---

# REUSABILITY & COMPONENT ENFORCEMENT (STRICT)

This project already has centralized reusable components.
Never duplicate existing abstractions.

---

## FORM CONTROLS (MANDATORY)

All form elements MUST use shared controls from:

import { Form, Field } from 'src/components/hook-form';

Includes:
- Input fields
- Number fields
- Date pickers
- Selects
- Autocomplete
- Switches
- Checkboxes
- Buttons

Rules:

- Do NOT use raw MUI inputs directly in forms.
- Do NOT create new wrappers unless absolutely required.
- Always check this file first.
- If extension needed → extend inside same file.
- Never duplicate form logic elsewhere.

---

## TABLE / GRID RULE (MANDATORY)

All list pages MUST use:

import { CustomTable } from 'src/components/custom-table';

Rules:

- Do NOT import MUI DataGrid directly in feature modules.
- Do NOT create new grid wrappers.
- Use server-side pagination via this abstraction.
- Sorting & filtering must flow through this component.
- If enhancement needed → modify shared component.
- Never fork or duplicate table logic.

### List-view error handling (MANDATORY)

When the list is driven by an RTK Query (or similar) that can error, pass the query error and retry into CustomTable so error UI is consistent and uses getApiErrorMessage internally.

On every CustomTable used for a list view that fetches list data:

- Pass `error={error}` (the query error from useGetXQuery or equivalent).
- Pass `onRetry={refetch}` (the query refetch function).
- Pass `errorEntityLabel="<entity>"` (plural or label used in the title, e.g. "items", "tenants", "recipes", "payment modes").

Example:

```jsx
<CustomTable
  rows={rows}
  columns={columns}
  loading={isLoading}
  actions={actions}
  error={error}
  onRetry={refetch}
  errorEntityLabel="items"
  pagination={{ ... }}
  emptyContent={...}
/>
```

Rules:

- Do NOT render a separate list error UI in list views (no early return with EmptyContent, no `error ? (Card + EmptyContent) : (CustomTable)`). CustomTable shows error in the table area when `error` is set and keeps search/filters/Create visible (inline error UX).
- Do NOT inline error message logic (e.g. `error?.data?.message || 'An error occurred...'`) in list views; CustomTable uses getApiErrorMessage(error, { defaultMessage }) and shows Retry only when isRetryable.
- If the list view has a prerequisite state (e.g. "Select a branch"), keep that as a separate branch (e.g. Card with EmptyContent); pass error/onRetry/errorEntityLabel to CustomTable for the data-fetch error only.

---

## API ERROR MESSAGE (MANDATORY)

All RTK Query / API error handling (list views, form dialogs, details dialogs) MUST use the shared helper:

import { getApiErrorMessage } from 'src/utils/api-error-message';

Rules:

- Do NOT inline error status checks (404, 500, offline, FETCH_ERROR) in catch blocks or query error UI.
- Use getApiErrorMessage(err, { defaultMessage, notFoundMessage?, validationMessage? }) for mutation catch and query error display.
- Use the returned message for toast or in-dialog error text; use isRetryable when showing a Retry action.
- If new error scenarios are needed, extend src/utils/api-error-message.js; never duplicate logic in features.
- **List views:** Do not render list-fetch error UI in the list view; pass `error`, `onRetry`, and `errorEntityLabel` to CustomTable (see TABLE / GRID RULE → List-view error handling). CustomTable uses getApiErrorMessage internally for list errors.

---

## QUERY STATE CONTENT (MANDATORY)

Dialog content that depends on API data (details dialogs, form dialogs in edit mode) MUST use the shared wrapper for loading, error, empty, and success states:

import { QueryStateContent } from 'src/components/query-state-content';

Use for:

- Details dialogs: loading, error (with Retry), optional empty (e.g. "not found"), then content.
- Form dialogs (edit mode): loading, error (with Retry), then form. Create mode: no wrapper needed (no fetch).

Rules:

- Do NOT duplicate inline loading/error UI (Box + Typography + Retry button) in dialog content. Use QueryStateContent.
- Pass a single `isLoading` (caller may combine multiple APIs, e.g. main entity + dropdowns).
- Pass `error` and `errorMessageOptions` (defaultMessage, notFoundMessage?, validationMessage?) so the wrapper uses getApiErrorMessage internally. Do NOT inline getApiErrorMessage in dialog body for these states.
- Pass `onRetry` (e.g. refetch from the query) when the user should be able to retry; omit when no retry is appropriate.
- For details dialogs, set `isEmpty` and `emptyMessage` when the entity is missing after a successful response (e.g. "not found").
- Loading UI: default is skeleton (reduces layout shift). Use `loadingVariant="spinner"` or `loadingNode` only when needed.
- If enhancement is needed (e.g. new loading variant), extend src/components/query-state-content; do not fork in features.


All form validation MUST use centralized schemas from:

import { createBranchSchema, updateBranchSchema } from 'src/schemas';
// or other createXSchema / updateXSchema from src/schemas

Rules:

- Do NOT define validation schemas in section-level files (e.g. src/sections/**/schemas/*-schema.js).
- Do NOT use raw Zod without the shared builders from src/schemas/fields.js and src/schemas/phone.js where applicable.
- Import create/update (and other) schemas from `src/schemas` or `src/schemas/<entity>`; domain schemas live under src/schemas and compose from fields.js and phone.js only.

---

## DIALOG USAGE & UX DECISION RULE (MANDATORY)

Standard dialogs:

import { CustomDialog } from 'src/components/custom-dialog';
import { ConfirmDialog } from 'src/components/custom-dialog/confirm-dialog';


Rules:

- Destructive or confirmation actions  
  → MUST use `confirm-dialog.jsx`

- Small, quick interactions  
  → Use `custom-dialog.jsx` only if UX is not degraded

### Dialog vs Page Decision Framework

Use Dialog ONLY if:

- ≤ 5–6 fields
- No complex dependencies
- No multi-step flows
- Can be completed in < 20 seconds
- No vertical scroll on tablet

Use Full Page if:

- Many or grouped fields
- Business-critical workflows (Tenant, Branch, Roles, Pricing)
- Needs explanations, permissions, review
- Risk of data loss is high
- Dialog feels cramped

Mandatory Rule:
If UX is degraded → always use a full page instead of forcing a dialog.

Dialogs must:

- Never exceed 80% viewport height
- Never stack dialogs
- Warn on unsaved changes
- Never block checkout flows

---

## CRUD PAGE STRUCTURE RULE

For any entity with Create + Edit:

- Use ONE shared form component
- Detect mode via route param
- Reuse same validation schema
- Reuse same layout

Structure:

- `/module/page.jsx` → List  
- `/module/new/page.jsx` → Create (uses shared form)  
- `/module/[id]/page.jsx` → Edit (same shared form)

Never create separate Add/Edit form components.

---

# DURING Implementation

- Write production-grade code
- Prefer clarity over cleverness
- No hacks or shortcuts
- Strong typing mindset
- Validate inputs on client (Zod) and server
- Handle loading, empty, error states explicitly
- Prevent double submissions
- Handle concurrency safely
- Lazy-load heavy admin components
- Keep checkout lightweight
- Avoid unnecessary re-renders
- Avoid memory-heavy client components
- Follow RTK Query best practices (tagTypes + invalidation)
- Follow linter standards on every edit; fix any new lint errors or warnings immediately—do not defer

---

# AFTER Implementation

Perform internal QA simulation:

1. Cashier rush hour test  
2. Slow 3G simulation  
3. Offline mode test  
4. Rapid tap stress test  
5. Multi-tab conflict test  
6. Payment retry scenario  
7. Branch isolation test  
8. Tenant isolation test  
9. Role permission test  
10. Large dataset grid test (50k+ records)  
11. Lint check: ensure no new linter errors or warnings on changed files

Provide:

- Functional test scenarios  
- Edge case scenarios  
- Failure mode behavior  
- Performance risks  
- Scalability considerations  
- Cache invalidation risks  
- Data integrity risks  
- Cross-tenant leakage risks  

---

# QUALITY BAR

- Must pass senior engineering review
- Must pass UX clarity test
- Must handle mobile keyboards correctly
- Must degrade gracefully under failure
- Must not expose cross-tenant data
- Must enforce tenant & branch isolation
- Must scale to 1000+ tenants
- Must be maintainable long-term
- Must avoid SSR/hydration mismatch issues

---

# DO NOT

- Jump straight to code
- Over-engineer prematurely
- Add visual noise
- Ignore offline scenarios
- Ignore accessibility
- Assume admin and POS share same UX
- Optimize for beauty over reliability
- Put business logic inside React components
- Trust frontend tenant context blindly
- Use heavy grids inside checkout
- Duplicate shared components
- Create separate Add/Edit pages unnecessarily
- Leave linter errors or warnings to fix later; fix them within the same task
