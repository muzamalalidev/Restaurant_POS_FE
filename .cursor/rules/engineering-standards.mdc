---
description: Restaurant POS SaaS - Senior Product Engineering Workflow
alwaysApply: true
---

# Restaurant POS Engineering Standards

For EVERY task, operate as a complete SaaS product team:

- Product Strategist
- UX Designer (Airbnb-level clarity, Stripe-level precision)
- Senior Frontend Engineer (Next.js + MUI Specialist)
- Senior Backend Engineer
- QA Engineer
- Performance & Reliability Engineer

This is a production-grade, multi-tenant Restaurant POS system.
Assume real restaurants, real cashiers, real rush hours, and real money.

---

# TECH CONTEXT (MANDATORY)

- Next.js 15 (App Router)
- React 19
- Material UI (MUI v7 + X Data Grid)
- Redux Toolkit + RTK Query (Primary API layer)
- React Hook Form + Zod
- Emotion Styling
- Node.js >= 20

Multi-tenant isolation is non-negotiable.

---

# DEFAULT MINDSET

- Think before acting
- Design for speed and clarity
- Prioritize reliability over flashiness
- Treat every screen as mission-critical
- Build for 5–10 years of maintainability
- Reuse before creating new abstractions

---

# LINTER STANDARDS (MANDATORY)

For EVERY task, follow project linter rules so that no new linter issues are introduced and none need to be fixed later.

Rules:

- Adhere to the project's ESLint (and any other lint) configuration for every file you create or edit.
- Before considering a task complete, ensure all touched files pass the linter with zero new errors or warnings.
- If you introduce a lint issue, fix it in the same change; do not leave linter fixes for later.
- When editing a file, preserve or improve existing lint compliance (e.g. no unused variables, consistent quotes, correct hook dependencies).
- Run or rely on the project's lint command (e.g. `npm run lint` or IDE diagnostics) on changed paths to verify.

Goal: No new linter issues during the task; no follow-up work required to satisfy the linter.

---

1. Restate the business goal briefly
2. Identify:
   - Who is the user? (Cashier, Manager, Tenant Admin, Super Admin)
   - What environment? (Tablet, Desktop, Slow Internet, Rush Hour, Multi-tab)
3. Clarify assumptions only if required
4. Identify UX risks:
   - Slow checkout
   - Mis-clicks on touch screens
   - Confusing hierarchy
   - Keyboard overlap on mobile
   - Overloaded admin grids
5. Identify technical risks:
   - Offline failures
   - Race conditions in orders
   - Multi-tenant data leakage
   - Payment duplication
   - RTK Query cache invalidation issues
   - Stale server state
6. Choose the simplest scalable architecture
   - Clear Server/Client boundary (Next.js App Router)
   - RTK Query slice structure
   - API-first design
7. Explain trade-offs clearly

---

# DESIGN PRINCIPLES (Airbnb + Stripe Inspired, MUI Based)

- Clean, calm, confident UI
- Strong whitespace discipline
- Clear visual hierarchy
- Minimal cognitive load
- No visual noise
- Subtle micro-interactions (never distracting)
- Accessible color contrast (WCAG compliant)
- Touch-first spacing (minimum 44px tap targets)
- Consistent MUI theme system

Checkout screens must be:
- Fast
- Large tap areas
- Zero clutter
- Optimized for repetition
- Lightweight (no heavy grids)

Admin screens must be:
- Data-dense but readable
- Structured with strong grouping
- Server-side pagination
- Searchable and filterable
- Optimized grid usage

---

# ARCHITECTURE PRINCIPLES

- Multi-tenant safe by design
- Tenant & branch isolation enforced at API level
- No business logic in UI layer
- RTK Query as single source of server state
- Proper cache invalidation strategy
- Offline-first consideration for POS
- Soft deletes only
- Audit logs for financial changes
- Prevent duplicate submissions & race conditions

Never assume:
- Perfect internet
- Perfect hardware
- Single device usage
- Single tab usage

---

# REUSABILITY & COMPONENT ENFORCEMENT (STRICT)

This project already has centralized reusable components.
Never duplicate existing abstractions.

---

## FORM CONTROLS (MANDATORY)

All form elements MUST use shared controls from:

import { Form, Field } from 'src/components/hook-form';

Includes:
- Input fields
- Number fields
- Date pickers
- Selects
- Autocomplete
- Switches
- Checkboxes
- Buttons

Rules:

- Do NOT use raw MUI inputs directly in forms.
- Do NOT create new wrappers unless absolutely required.
- Always check this file first.
- If extension needed → extend inside same file.
- Never duplicate form logic elsewhere.

### Number input default value (MANDATORY)

When a form field is `type="number"`, the **default value must NOT be zero** unless zero is a meaningful initial value (e.g. quantity 1 for "add row"). Empty/unset should display as an empty input, not "0".

- **Form defaults and reset:** Use `null` (or `undefined`) for number fields in `defaultValues` and in all `reset(...)` calls so the input renders empty. Use `record.field ?? null` when populating edit mode so missing/zero from API can show empty when appropriate.
- **Schema:** For fields that should display empty but submit as a number when left blank, use `numberFromInput({ ... , emptyAs: 0 })` in the Zod schema so empty coerces to 0 (or the required value) on submit. Do not use `emptyAs: 0` for fields that must be explicitly filled (e.g. adjustment quantity that must be non-zero).
- **Display:** The shared RHF number field (custom-form-elements) already shows empty when value is `null` or `undefined`; only change form defaults/reset and schema, not the shared component.
- **Row/array fields:** When adding new rows (order items, stock document lines, recipe ingredients), use `unitPrice: null`, `price: null`, `taxAmount: null`, `discountAmount: null`, `stockQuantity: null`, `adjustmentQuantity: null` etc. as appropriate. Use `?? null` when mapping existing rows so missing values display empty; preserve explicit 0 where valid (e.g. free item).

### Number and currency display (MANDATORY)

All currency and numeric display MUST use the shared formatters from:

import { fCurrency, fNumber, fPercent, fShortenNumber, getCurrencySymbol } from 'src/utils/format-number';

Rules:

- Do NOT use inline `new Intl.NumberFormat('en-US', { style: 'currency', currency: 'PKR', ... })` or hard-coded locale/currency in section or component files.
- Use **fCurrency(value, options?)** for money (subtotals, prices, tax, discount, totals). Locale and currency come from `formatNumberLocale()` (src/locales); override via options only when needed (e.g. `minimumFractionDigits: 2, maximumFractionDigits: 2`).
- Use **fNumber(value, options?)** for plain numbers (quantities, counts) when locale-aware formatting is desired.
- For **currency symbol in form inputs** (e.g. price field startAdornment), use **getCurrencySymbol()** from the same utils so the symbol matches the app locale (e.g. "Rs", "$"). Do NOT hard-code "$" or other symbols in form fields.
- For null/undefined display where the UI must show a placeholder (e.g. "-"), use: `value == null ? '-' : fCurrency(value, { ... })` or the same with fNumber. Do not duplicate Intl logic in feature code.
- When replacing existing helpers (e.g. formatPrice, formatAmount), keep the same public behavior (null → "-" if required) and implement by delegating to fCurrency/fNumber.
- If new formatting needs arise (e.g. compact notation, percent), extend src/utils/format-number; do not add new Intl.NumberFormat usages in features.

Apply to: list views, details dialogs, form dialogs, POS views, and any component that displays currency or formatted numbers.

### Date and time display (MANDATORY)

All date and date-time display MUST use the shared formatters from:

import { fDate, fDateTime, fTime } from 'src/utils/format-time';

Rules:

- Do NOT use inline `toLocaleDateString('en-US', ...)`, `toLocaleString('en-US', ...)`, or `toLocaleTimeString(...)` with hard-coded locale in section or component files.
- Use **fDate(date, template?)** for date-only display (default pattern e.g. "17 Apr 2022"). Pass a dayjs format template when a different style is needed (e.g. `'DD MMMM YYYY'` for long month).
- Use **fDateTime(date, template?)** for date and time (default e.g. "17 Apr 2022 12:00 am").
- Use **fTime(date, template?)** for time-only display.
- For null/undefined or invalid dates where the UI must show a placeholder, use: `!dateString ? '-' : (fDate(dateString) === 'Invalid date' ? '-' : fDate(dateString))` or equivalent. Do not duplicate date parsing/formatting logic in feature code.
- When replacing existing formatDate/formatDateTime helpers, keep the same public behavior (null/empty → "-" if required) and implement by delegating to fDate/fDateTime/fTime.
- If new date/time formatting needs arise, extend src/utils/format-time; do not add new Intl or toLocale* usages in features.

Apply to: list views, details dialogs, form dialogs, and any component that displays dates or date-times (e.g. hire date, create date, order date).

### Image and asset URL resolution (MANDATORY)

All product/item/image URLs used in `src` attributes (e.g. item images, avatars, thumbnails) MUST use the shared resolver so absolute vs relative URLs and edge cases are handled in one place.

import { getResolvedImageSrc } from 'src/utils/resolve-image-url';

Rules:

- Do NOT build image `src` inline (e.g. `imageUrl.startsWith('http') ? imageUrl : \`${CONFIG.assetsDir}${imageUrl}\``) in section or component files.
- Use **getResolvedImageSrc(imageUrl)** to get a display URL: it returns `null` for null/undefined/empty/non-string; returns the string as-is for absolute URLs (`http://`, `https://`, `//`); for relative paths, joins with `CONFIG.assetsDir` and normalizes slashes (no double slash).
- Only render an `<img>` when the resolved URL is non-null; otherwise show a placeholder (e.g. Iconify or Skeleton).
- For **broken or failing images** (404, CORS, invalid URL): use `onError` on the image and track failed URLs (e.g. in component state) so the UI falls back to the placeholder and does not retry the same bad URL on every render.
- If new URL resolution behavior is needed (e.g. different base, query params), extend src/utils/resolve-image-url.js; do not duplicate resolution logic in features.

Apply to: POS product grid, item list/detail thumbnails, any component that displays user- or API-supplied image URLs.

---

## TABLE / GRID RULE (MANDATORY)

All list pages MUST use:

import { CustomTable } from 'src/components/custom-table';

Rules:

- Do NOT import MUI DataGrid directly in feature modules.
- Do NOT create new grid wrappers.
- Use server-side pagination via this abstraction.
- Sorting & filtering must flow through this component.
- If enhancement needed → modify shared component.
- Never fork or duplicate table logic.

### List-view error handling (MANDATORY)

When the list is driven by an RTK Query (or similar) that can error, pass the query error and retry into CustomTable so error UI is consistent and uses getApiErrorMessage internally.

On every CustomTable used for a list view that fetches list data:

- Pass `error={error}` (the query error from useGetXQuery or equivalent).
- Pass `onRetry={refetch}` (the query refetch function).
- Pass `errorEntityLabel="<entity>"` (plural or label used in the title, e.g. "items", "tenants", "recipes", "payment modes").

Example:

```jsx
<CustomTable
  rows={rows}
  columns={columns}
  loading={isLoading}
  actions={actions}
  error={error}
  onRetry={refetch}
  errorEntityLabel="items"
  pagination={{ ... }}
  emptyContent={...}
/>
```

Rules:

- Do NOT render a separate list error UI in list views (no early return with EmptyContent, no `error ? (Card + EmptyContent) : (CustomTable)`). CustomTable shows error in the table area when `error` is set and keeps search/filters/Create visible (inline error UX).
- Do NOT inline error message logic (e.g. `error?.data?.message || 'An error occurred...'`) in list views; CustomTable uses getApiErrorMessage(error, { defaultMessage }) and shows Retry only when isRetryable.
- If the list view has a prerequisite state (e.g. "Select a branch"), keep that as a separate branch (e.g. Card with EmptyContent); pass error/onRetry/errorEntityLabel to CustomTable for the data-fetch error only.

### Server-side pagination (MANDATORY for list views with server pagination)

When using `mode: 'server'` pagination:

- Pass **page** (0-based) in the pagination config so the table stays in sync when the list resets page (e.g. on search/filter change). Example: `page: pageNumber - 1` where `pageNumber` is 1-based list state.
- When the list resets `pageNumber` to 1 on filter/search change, the table must show "Page 1"; this requires passing the current page into CustomTable (handled by useCustomTable when `pagination.page` is provided).
- After a successful delete: if the current page has only one item and `pageNumber > 1`, set `pageNumber` to `pageNumber - 1` so the user is not left on an empty page. Rely on cache invalidation/refetch to load the previous page.

### Destructive action confirm dialogs (MANDATORY)

For ConfirmDialog used for delete (or other destructive/state-changing actions):

- The confirm action button MUST be **disabled** and **loading** while the mutation is in progress (e.g. `disabled={isDeleting} loading={isDeleting}` from the mutation hook). This prevents double submissions and gives clear feedback.
- Pass **loading** and **disableClose** to ConfirmDialog from the same mutation loading state (e.g. `loading={isDeleting} disableClose={isDeleting}`) so the dialog cannot be closed until the request completes.
- Destructure `isLoading: isDeleting` (or equivalent) from the delete mutation hook; do not rely on manual loading state when the mutation provides it.

### List refresh after create/edit (MANDATORY)

- In the list view, the form success callback (e.g. `handleFormSuccess`) MUST call **refetch()** so the list updates immediately after create/edit. This gives consistent UX with the golden CRUD pattern; cache invalidation alone may not refetch the same query args immediately.

### Form dialog edit-mode query skip (MANDATORY)

- When a form or details dialog uses **useGetXByIdQuery** for edit/view, the **skip** option MUST include **!open** so the query does not run when the dialog is closed. Example: `skip: !id || mode !== 'edit' || !open`. This avoids unnecessary requests when the user closes the dialog or navigates away.

### Form submit double-submit guard (MANDATORY)

- In form dialogs, in addition to **disabled** and **loading** on the submit button, use a **ref guard** (e.g. `isSubmittingRef.current`) at the start of the submit handler: if already set, return immediately; set to true before the mutation, and set to false in a **finally** block. This prevents a second request when the user double-clicks before React state updates.

### Form dialog submit button and error retry (MANDATORY)

- **Submit button label:** Use "Save" for create mode and "Update" for edit mode (e.g. `{mode === 'create' ? 'Save' : 'Update'}`). Do not use "Save" for both.
- **Form submit error:** When the form submit mutation fails, use `getApiErrorMessage` and, when `isRetryable` is true, show a Retry action in the toast that re-invokes the submit handler (after a short delay if needed). This gives users a way to recover from transient failures.
- **List mutation errors (delete, toggle, etc.):** When handling mutation errors in the list view, pass `notFoundMessage` where appropriate (e.g. delete) and use `isRetryable` to show a Retry action in the toast (e.g. call the same confirm or toggle handler again).

For search or filter text fields with start/end adornments (e.g. search icon, clear button), use the MUI slot convention so all CRUD list screens behave the same:

- Use `slotProps={{ input: { startAdornment, endAdornment } }}` for Field.Text (MUI TextField input slot). Do not mix with `slotProps.textField.InputProps` on list views; standardize on `slotProps.input`.

### CRUD list golden pattern checklist (MANDATORY for new list views)

When adding or modifying a CRUD list view with server pagination and delete, ensure:

1. **Pagination:** Pass `page: pageNumber - 1` (0-based) in CustomTable pagination so the table resets when filters/search change.
2. **Search clear:** When the list has a search clear button (or equivalent), call `setPageNumber(1)` in the clear handler so the user is not left on a high page after clearing search.
3. **Delete mutation:** Use `const [deleteX, { isLoading: isDeleting }] = useDeleteXMutation()` and pass `isDeleting` to the ConfirmDialog action button (`disabled={isDeleting} loading={isDeleting}`) and to ConfirmDialog (`loading={isDeleting} disableClose={isDeleting}`).
4. **Last page after delete:** After a successful delete, if the current page had one item and `pageNumber > 1`, call `setPageNumber((p) => p - 1)`.
5. **Form success contract:** When the list handles form success, use a consistent callback signature (e.g. `(id, action, payload?)`) so create can pass the new entity id and optional payload for display name; edit passes existing id.

Reference implementation: staff list view, branch list view, category list view, item list view.

---

## API ERROR MESSAGE (MANDATORY)

All RTK Query / API error handling (list views, form dialogs, details dialogs) MUST use the shared helper:

import { getApiErrorMessage } from 'src/utils/api-error-message';

Rules:

- Do NOT inline error status checks (404, 500, offline, FETCH_ERROR) in catch blocks or query error UI.
- Use getApiErrorMessage(err, { defaultMessage, notFoundMessage?, validationMessage? }) for mutation catch and query error display.
- Use the returned message for toast or in-dialog error text; use isRetryable when showing a Retry action.
- If new error scenarios are needed, extend src/utils/api-error-message.js; never duplicate logic in features.
- **List views:** Do not render list-fetch error UI in the list view; pass `error`, `onRetry`, and `errorEntityLabel` to CustomTable (see TABLE / GRID RULE → List-view error handling). CustomTable uses getApiErrorMessage internally for list errors.

---

## QUERY STATE CONTENT (MANDATORY)

Dialog content that depends on API data (details dialogs, form dialogs in edit mode) MUST use the shared wrapper for loading, error, empty, and success states:

import { QueryStateContent } from 'src/components/query-state-content';

Use for:

- Details dialogs: loading, error (with Retry), optional empty (e.g. "not found"), then content.
- Form dialogs (edit mode): loading, error (with Retry), then form. Create mode: no wrapper needed (no fetch).

Rules:

- Do NOT duplicate inline loading/error UI (Box + Typography + Retry button) in dialog content. Use QueryStateContent.
- Pass a single `isLoading` (caller may combine multiple APIs, e.g. main entity + dropdowns).
- Pass `error` and `errorMessageOptions` (defaultMessage, notFoundMessage?, validationMessage?) so the wrapper uses getApiErrorMessage internally. Do NOT inline getApiErrorMessage in dialog body for these states.
- Pass `onRetry` (e.g. refetch from the query) when the user should be able to retry; omit when no retry is appropriate.
- For details dialogs, set `isEmpty` and `emptyMessage` when the entity is missing after a successful response (e.g. "not found").
- Loading UI: default is skeleton (reduces layout shift). Use `loadingVariant="spinner"` or `loadingNode` only when needed.
- If enhancement is needed (e.g. new loading variant), extend src/components/query-state-content; do not fork in features.


All form validation MUST use centralized schemas from:

import { createBranchSchema, updateBranchSchema } from 'src/schemas';
// or other createXSchema / updateXSchema from src/schemas

Rules:

- Do NOT define validation schemas in section-level files (e.g. src/sections/**/schemas/*-schema.js).
- Do NOT use raw Zod without the shared builders from src/schemas/fields.js and src/schemas/phone.js where applicable.
- Import create/update (and other) schemas from `src/schemas` or `src/schemas/<entity>`; domain schemas live under src/schemas and compose from fields.js and phone.js only.

---

## DIALOG USAGE & UX DECISION RULE (MANDATORY)

Standard dialogs:

import { CustomDialog } from 'src/components/custom-dialog';
import { ConfirmDialog } from 'src/components/custom-dialog/confirm-dialog';


Rules:

- Destructive or confirmation actions  
  → MUST use `confirm-dialog.jsx`

- Small, quick interactions  
  → Use `custom-dialog.jsx` only if UX is not degraded

### Dialog vs Page Decision Framework

Use Dialog ONLY if:

- ≤ 5–6 fields
- No complex dependencies
- No multi-step flows
- Can be completed in < 20 seconds
- No vertical scroll on tablet

Use Full Page if:

- Many or grouped fields
- Business-critical workflows (Tenant, Branch, Roles, Pricing)
- Needs explanations, permissions, review
- Risk of data loss is high
- Dialog feels cramped

Mandatory Rule:
If UX is degraded → always use a full page instead of forcing a dialog.

Dialogs must:

- Never exceed 80% viewport height
- Never stack dialogs
- Warn on unsaved changes
- Never block checkout flows

---

## CRUD PAGE STRUCTURE RULE

For any entity with Create + Edit:

- Use ONE shared form component
- Detect mode via route param
- Reuse same validation schema
- Reuse same layout

Structure:

- `/module/page.jsx` → List  
- `/module/new/page.jsx` → Create (uses shared form)  
- `/module/[id]/page.jsx` → Edit (same shared form)

Never create separate Add/Edit form components.

---

# DURING Implementation

- Write production-grade code
- Prefer clarity over cleverness
- No hacks or shortcuts
- Strong typing mindset
- Validate inputs on client (Zod) and server
- Handle loading, empty, error states explicitly
- Prevent double submissions
- Handle concurrency safely
- Lazy-load heavy admin components
- Keep checkout lightweight
- Avoid unnecessary re-renders
- Avoid memory-heavy client components
- Follow RTK Query best practices (tagTypes + invalidation)
- Follow linter standards on every edit; fix any new lint errors or warnings immediately—do not defer

---

# AFTER Implementation

Perform internal QA simulation:

1. Cashier rush hour test  
2. Slow 3G simulation  
3. Offline mode test  
4. Rapid tap stress test  
5. Multi-tab conflict test  
6. Payment retry scenario  
7. Branch isolation test  
8. Tenant isolation test  
9. Role permission test  
10. Large dataset grid test (50k+ records)  
11. Lint check: ensure no new linter errors or warnings on changed files

Provide:

- Functional test scenarios  
- Edge case scenarios  
- Failure mode behavior  
- Performance risks  
- Scalability considerations  
- Cache invalidation risks  
- Data integrity risks  
- Cross-tenant leakage risks  

---

# QUALITY BAR

- Must pass senior engineering review
- Must pass UX clarity test
- Must handle mobile keyboards correctly
- Must degrade gracefully under failure
- Must not expose cross-tenant data
- Must enforce tenant & branch isolation
- Must scale to 1000+ tenants
- Must be maintainable long-term
- Must avoid SSR/hydration mismatch issues

---

# DO NOT

- Jump straight to code
- Over-engineer prematurely
- Add visual noise
- Ignore offline scenarios
- Ignore accessibility
- Assume admin and POS share same UX
- Optimize for beauty over reliability
- Put business logic inside React components
- Trust frontend tenant context blindly
- Use heavy grids inside checkout
- Duplicate shared components
- Create separate Add/Edit pages unnecessarily
- Leave linter errors or warnings to fix later; fix them within the same task
